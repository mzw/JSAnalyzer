package jp.mzw.jsanalyzer.parser;

import java.io.FileReader;

import jp.mzw.jsanalyzer.util.StringUtils;

import org.mozilla.javascript.CompilerEnvirons;
import org.mozilla.javascript.Context;
import org.mozilla.javascript.ContextFactory;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.tools.shell.Global;

/**
 * Parses JavaScript code
 * @author Yuta Maezawa
 *
 */
public class JSParser extends Parser {

	/**
	 * An abstract syntax tree
	 */
	protected AstRoot mAst;
	
	/**
	 * Constructor
	 * @param code JS code
	 */
	public JSParser(JSCode code) {
		super(code);
		this.mAst = this.createAST(code.getCode());
	}

	/**
	 * Creates an abstract syntax tree from given JS code
	 * @param jsCode A JS code to be parsed
	 * @return An abstract syntax tree
	 */
	private AstRoot createAST(String jsCode) {
		AstRoot ast = null;
		
		jsCode = preprocessJsCodeForParsing(jsCode);
		
		Global global = new Global(); 
		Context cx = ContextFactory.getGlobal().enterContext();
		global.init(cx);
		try {
			Scriptable scope = cx.initStandardObjects(global);
			cx.setOptimizationLevel(-1); // bypass 64kb size limit
			cx.evaluateReader(scope, new FileReader("res/js/env.rhino.1.2.js"), "env.rhino.js", 1, null);
			
			CompilerEnvirons ce = new CompilerEnvirons();
			ce.initFromContext(cx);
			org.mozilla.javascript.Parser parser = new org.mozilla.javascript.Parser(ce);
			
			ast = parser.parse(jsCode, "", 1);
			
			if(ast == null) {
				StringUtils.printError(this, "Fail to parse");
			}
		} catch(Exception e) {
			e.printStackTrace();
		} finally {
			Context.exit();
		}
		return ast;
	}
	
	/**
	 * Ad-hoc workarounds for incomplete analysis by code replacement.
	 * This can break original semantic and in the worst case,
	 * replaced jsCode become syntactically invalid.
	 * In the future, this method should be removed.
	 * @author Kazuki Nishiura
	 * @param jsCode An original JS code
	 * @return A pre-processed JS code
	 * @deprecated
	 */
    private String preprocessJsCodeForParsing(String jsCode) {
            // Because we cannot resolve the event target when it's not stored in variable,
            // replace something like "document.getElementById('hoge')."
            // to "var autogenerated_hoge = document.getElementById('hoge'); autogenerated_hoge."
            jsCode = jsCode.replaceAll("document\\.getElementById\\('([a-zA-Z0-9_]+)'\\)\\.",
                            "var  autogenerated_$1 = document.getElementById('$1'); autogenerated_$1.");

            // jQuery variable $ is used both as function and object. To avoid our analyzer get confused,
            // if $ is used as object, we replace it to jQuery, which represents same object.
            jsCode = jsCode.replaceAll("\\$\\.", "jQuery.");

            // onSubmit can take value like 'return func();', but this sentence itself is syntactically
            // invalid when parsed as independent JavaScript. Here we remove 'return' word.
            if (jsCode.startsWith("return") && (jsCode.endsWith("();") || jsCode.endsWith("()"))) {
                    jsCode = jsCode.substring("return".length(), jsCode.length()).trim();
            }

            return jsCode;
    }
}
